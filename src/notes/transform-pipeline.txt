// --- Transform pipeline rationale ---
//
// In our demos we apply 3 transforms in sequence:
//
//   sk.applyMatrix(1, 0, 0, -1, 0, CANVAS_HEIGHT);         // M1
//   sk.applyMatrix(CANVAS_WIDTH, 0, 0, CANVAS_HEIGHT, 0, 0); // M2
//   sk.applyMatrix(sx, 0, 0, sy, tx, ty);                  // M3
//
// These combine into one matrix M = M1 * M2 * M3.
// For a point p in world coords, final coords are p' = p * M.
//
// --- Breakdown ---
//
// M3: World → Viewport (in NDC)
//   [ sx   0  tx ]
//   [ 0   sy  ty ]
//   [ 0    0   1 ]
//
//   - Maps a user-specified world window (e.g. [-10,10]x[-5,5])
//     into the normalized [0,1] × [0,1] "viewport" space.
//   - This is the classic "window-to-viewport" transform.
//
// M2: NDC → Device Coordinates (scale to pixel space)
//   [ W   0   0 ]
//   [ 0   H   0 ]
//   [ 0   0   1 ]
//
//   - Expands normalized [0,1] coords into pixel dimensions.
//   - (0,0) → bottom-left pixel, (1,1) → top-right pixel.
//   - W = canvas width, H = canvas height.
//
// M1: Reflection + Translation (Canvas space → Cartesian space)
//   [ 1   0   0 ]
//   [ 0  -1   H ]
//   [ 0   0   1 ]
//
//   - Flips the y-axis so that "up" is positive (Cartesian orientation).
//   - Then translates by +H so the origin moves from top-left to bottom-left.
//   - This is a reflection across the x-axis followed by a vertical shift.
//
// --- Transformation Stack View ---
//
//    World coords
//       │
//       ▼
//   M3: World → Viewport (NDC)
//       │
//       ▼
//   M2: NDC → Device coords (pixels)
//       │
//       ▼
//   M1: Reflection + Translation (to Cartesian screen)
//       │
//       ▼
//    Final screen coords
//
// Note on order:
// - Mathematically: p' = p * (M1 * M2 * M3).
// - Because of post-multiplication, the *last-applied* matrix (M3)
//   sits at the top of the stack and acts first on coordinates.
//
// --- Summary ---
// 1. Define world coords in natural math space.
// 2. M3 maps world window → [0,1] viewport (NDC).
// 3. M2 scales NDC → pixel device coords.
// 4. M1 reflects + translates so the canvas behaves like Cartesian paper.
//
// Net effect: you write math in world coords, the framework handles
// viewport, normalization, and device-space quirks automatically.
