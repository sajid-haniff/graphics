/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkgraphics"] = self["webpackChunkgraphics"] || []).push([["src_geometric_polygon-demo_js"],{

/***/ "./src/geometric/polygon-demo.js":
/*!***************************************!*\
  !*** ./src/geometric/polygon-demo.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"createPolygonDemo\": () => (/* binding */ createPolygonDemo)\n/* harmony export */ });\n/* harmony import */ var _graphics_context2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../graphics_context2 */ \"./src/graphics_context2.js\");\n/* harmony import */ var _lib_esm_vec3__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/esm/vec3 */ \"./src/lib/esm/vec3.js\");\n\n\n\nconst createPolygonDemo = (sk, CANVAS_WIDTH = 800, CANVAS_HEIGHT = 800) => {\n\n    // Define the drawing area and viewport\n    let win = {left: -100, right: 100, top: 100, bottom: -100};\n    let view = {left: 0.1, right: 0.9, top: 0.9, bottom: 0.1};\n\n    // Create a graphics context for drawing\n    const ctx = (0,_graphics_context2__WEBPACK_IMPORTED_MODULE_0__.createGraphicsContext2)(win, view, CANVAS_WIDTH, CANVAS_HEIGHT, sk);\n    const {sx, sy, tx, ty} = ctx.viewport;\n\n    return {\n        /**\n         * Setup function to initialize the canvas and background.\n         */\n        setup: () => {\n            const canvas = sk.createCanvas(CANVAS_WIDTH, CANVAS_HEIGHT);\n            canvas.id('canvas');\n            sk.background(40);\n            sk.noLoop(); // Prevent continuous looping\n        },\n\n        /**\n         * Display function to draw the triangle, incircle, and excircle.\n         */\n        display: () => {\n            // Apply transformations to the drawing context\n            sk.applyMatrix(1, 0, 0, -1, 0, CANVAS_HEIGHT);\n            sk.applyMatrix(CANVAS_WIDTH, 0, 0, CANVAS_HEIGHT, 0, 0);\n            sk.applyMatrix(sx, 0, 0, sy, tx, ty);\n\n            // Define vertices of a more complex polygon\n            /*const vertices = [\n                [-70, -50, 0],\n                [0, -70, 0],\n                [70, -50, 0],\n                [50, 0, 0],\n                [70, 50, 0],\n                [0, 70, 0],\n                [-70, 50, 0],\n                [-50, 0, 0]\n            ];*/\n            const vertices = [\n                [-50, -50, 0],\n                [50, -50, 0],\n                [70, 0, 0],\n                [50, 50, 0],\n                [-50, 50, 0],\n                [-70, 0, 0]\n            ];\n\n            // Create and draw the polygon\n            const polygon = ctx.createPolygon(vertices);\n\n            // Set fill and stroke colors\n            sk.fill(0, 150, 255, 100); // Light blue fill with transparency\n            sk.stroke(255, 204, 0); // Yellow stroke\n            sk.strokeWeight(2); // Thicker stroke\n\n            // Draw the filled polygon\n            sk.beginShape();\n            vertices.forEach(([x, y]) => sk.vertex(x, y));\n            sk.endShape(sk.CLOSE);\n\n            // Draw the edges of the polygon\n            polygon.draw();\n\n            // Draw the normals\n            sk.stroke(255, 0, 0); // Red color for normals\n            sk.strokeWeight(1);\n            polygon.edges.forEach(({edge, normal}) => {\n                const midX = (edge.start[0] + edge.end[0]) / 2;\n                const midY = (edge.start[1] + edge.end[1]) / 2;\n                sk.line(midX, midY, midX + normal[0] * 10, midY + normal[1] * 10); // Scale normal for visibility\n            });\n\n            // Initialize the clipper\n            const clipper = ctx.cyrusBeckClipper(polygon);\n\n            // Define test cases for different lines\n            const testLines = [\n                {p1: _lib_esm_vec3__WEBPACK_IMPORTED_MODULE_1__.fromValues(-75, -75, 0), p2: _lib_esm_vec3__WEBPACK_IMPORTED_MODULE_1__.fromValues(75, 75, 0)},  // Partially inside\n                {p1: _lib_esm_vec3__WEBPACK_IMPORTED_MODULE_1__.fromValues(-25, -25, 0), p2: _lib_esm_vec3__WEBPACK_IMPORTED_MODULE_1__.fromValues(25, 25, 0)},  // Completely inside\n                {p1: _lib_esm_vec3__WEBPACK_IMPORTED_MODULE_1__.fromValues(75, 75, 0), p2: _lib_esm_vec3__WEBPACK_IMPORTED_MODULE_1__.fromValues(100, 100, 0)},  // Completely outside\n                {p1: _lib_esm_vec3__WEBPACK_IMPORTED_MODULE_1__.fromValues(0, -75, 0), p2: _lib_esm_vec3__WEBPACK_IMPORTED_MODULE_1__.fromValues(0, 75, 0)},     // Intersecting top and bottom\n                {p1: _lib_esm_vec3__WEBPACK_IMPORTED_MODULE_1__.fromValues(-75, 0, 0), p2: _lib_esm_vec3__WEBPACK_IMPORTED_MODULE_1__.fromValues(75, 0, 0)},     // Intersecting left and right\n            ];\n\n            // Perform clipping and print results\n            testLines.forEach(({p1, p2}, index) => {\n                const line = ctx.createLine({type: 'points', p1, p2});\n                const clippedLine = clipper(line);\n\n                // Draw the original line in red\n                sk.stroke(255, 0, 0); // Red color for original line\n                sk.strokeWeight(2);\n                sk.line(p1[0], p1[1], p2[0], p2[1]);\n\n                if (clippedLine) {\n\n                    // Drawing the clipped line with a vibrant blue color and a stroke weight of 3\n                    sk.stroke(30, 144, 255); // DodgerBlue color\n                    sk.strokeWeight(3);\n                    clippedLine.draw();\n\n                } else {\n                    console.log(`Test Case ${index + 1}: Line is outside the polygon`);\n                }\n            });\n        }\n    };\n};\n\n\n//# sourceURL=webpack://graphics/./src/geometric/polygon-demo.js?");

/***/ })

}]);